# Task #6 - soa_record.email

## Summary
Implemented the `email` field within the `soa_record` block as a required string field with comprehensive validation. The field maps to `body.properties.soaRecord.email` in the post-creation SOA record update operation and includes both format validation and cross-field validation with the zone name.

## Shadow Implementation
```hcl
# In variables.tf
variable "soa_record" {
  # ... existing type definition ...
  
  validation { # <-
    condition = var.soa_record == null || ( # <-
      length(var.soa_record.email) > 0 && # <-
      length(split(".", var.soa_record.email)) >= 2 && # <-
      length(split(".", var.soa_record.email)) <= 34 && # <-
      alltrue([for segment in split(".", var.soa_record.email) : segment != ""]) && # <-
      alltrue([for segment in split(".", var.soa_record.email) : length(segment) <= 63]) && # <-
      can(regex("^[a-zA-Z0-9._-]+$", var.soa_record.email)) # <-
    )
    error_message = "The `email` must be a valid format: non-empty, between 2 and 34 dot-separated segments, each segment 1-63 characters, no consecutive periods, and only containing letters, numbers, underscores, dashes, and periods." # <-
  }
  
  validation { # <-
    condition = var.soa_record == null || ( # <-
      length(format("%s%s", var.name, trimsuffix(var.soa_record.email, "."))) <= 253 # <-
    )
    error_message = "The value for `email` which is concatenated with Private DNS Zone `name` cannot exceed 253 characters excluding a trailing period." # <-
  }
}

# In migrate_main.tf
locals {
  post_creation0 = var.soa_record != null ? {
    body = {
      properties = {
        soaRecord = {
          email = var.soa_record.email # <-
        }
      }
    }
  } : null
}
```

## Create Phase Verification

### Pattern: Post-Creation Operation
The `email` field is part of the SOA record, which is handled as a post-creation operation after the primary zone creation.

### Evidence from Create Method
From `resourcePrivateDnsZoneCreateUpdate`:

```go
// Phase 1: Primary zone creation
if err := client.CreateOrUpdateThenPoll(ctx, id, parameters, options); err != nil {
    return fmt.Errorf("creating/updating %s: %s", id, err)
}

// Phase 2: SOA record post-creation operation
if v, ok := d.GetOk("soa_record"); ok {
    soaRecordRaw := v.([]interface{})[0].(map[string]interface{})
    soaRecord := expandPrivateDNSZoneSOARecord(soaRecordRaw)  // <-- email field expanded here
    rsParameters := privatedns.RecordSet{
        Properties: &privatedns.RecordSetProperties{
            Ttl:       pointer.To(int64(soaRecordRaw["ttl"].(int))),
            Metadata:  tags.Expand(soaRecordRaw["tags"].(map[string]interface{})),
            SoaRecord: soaRecord,  // <-- soaRecord struct contains email
        },
    }

    recordId := privatedns.NewRecordTypeID(id.SubscriptionId, id.ResourceGroupName, id.PrivateDnsZoneName, privatedns.RecordTypeSOA, "@")

    // Cross-field validation for email + name length
    val := fmt.Sprintf("%s%s", id.PrivateDnsZoneName, strings.TrimSuffix(*soaRecord.Email, "."))
    if len(val) > 253 {
        return fmt.Errorf("the value %q for `email` which is concatenated with Private DNS Zone `name` cannot exceed 253 characters excluding a trailing period", val)
    }

    if _, err := recordSetsClient.RecordSetsCreateOrUpdate(ctx, recordId, rsParameters, createOptions); err != nil {
        return fmt.Errorf("creating/updating %s: %s", recordId, err)
    }
}
```

### SDK Function Classification
- **Operation**: `recordSetsClient.RecordSetsCreateOrUpdate()` - CreateOrUpdate function
- **Classification**: Post-creation operation → `post_creation0`
- **Resource Type**: `Microsoft.Network/privateDnsZones/SOA@2024-06-01`

### Decision
The `email` field is implemented in `local.post_creation0.body.properties.soaRecord.email` because it's processed in the post-creation SOA record update operation, not during the primary zone creation.

## Assignment Path Verification

### Predicted Path
`body.properties.soaRecord.email`

### Go Code Evidence

From `expandPrivateDNSZoneSOARecord`:
```go
func expandPrivateDNSZoneSOARecord(input map[string]interface{}) *privatedns.SoaRecord {
    return &privatedns.SoaRecord{
        Email:       pointer.To(input["email"].(string)),  // <-- email extracted from input
        ExpireTime:  pointer.To(int64(input["expire_time"].(int))),
        MinimumTtl:  pointer.To(int64(input["minimum_ttl"].(int))),
        RefreshTime: pointer.To(int64(input["refresh_time"].(int))),
        RetryTime:   pointer.To(int64(input["retry_time"].(int))),
    }
}
```

From Create method:
```go
rsParameters := privatedns.RecordSet{
    Properties: &privatedns.RecordSetProperties{  // <-- Properties assignment
        SoaRecord: soaRecord,  // <-- soaRecord nested under Properties
    },
}
```

### Assignment Trace
1. `input["email"]` → `SoaRecord.Email`
2. `SoaRecord` → `RecordSetProperties.SoaRecord`
3. `RecordSetProperties` → `RecordSet.Properties`
4. Final Azure API path: `body.properties.soaRecord.email`

### Verified Path
✅ **Match**: The predicted path `body.properties.soaRecord.email` matches the verified assignment trace through the Go code.

## Provider Schema

### Schema Definition
From the resource schema:
```go
"email": {
    Type:         pluginsdk.TypeString,
    Required:     true,
    ValidateFunc: validate.PrivateDnsZoneSOARecordEmail,
},
```

### Key Properties
- **Type**: String
- **Required**: true (must be provided when `soa_record` block is set)
- **Computed**: false
- **ForceNew**: Inherited from parent block (`soa_record` has `ForceNew: true`)
- **ValidateFunc**: Custom validation function `validate.PrivateDnsZoneSOARecordEmail`

## Azure API Schema

### Property Path
`body.properties.soaRecord.email`

### Azure API Type
From query result:
```
ObjectWithOptionalAttrs(map[string]Type{"email":String, ...})
```

### Azure API Documentation
"The email contact for this SOA record."

## Hidden Fields Check

### Analysis
No hidden fields. The `email` field directly maps from schema to API with no additional transformations or hidden values.

## Mapping (snake_case → camelCase)

| Schema Field | API Field | Notes |
|--------------|-----------|-------|
| `email` | `email` | No case change needed |

## Special Handling

### 1. Format Validation
The provider uses a custom validation function `PrivateDnsZoneSOARecordEmail` with multiple rules:

```go
func PrivateDnsZoneSOARecordEmail(v interface{}, k string) (warnings []string, errors []error) {
    value := v.(string)

    // Rule 1: Cannot be empty
    if len(value) == 0 {
        errors = append(errors, fmt.Errorf("%q cannot be an empty string: %q", k, v))
        return warnings, errors
    }

    // Rule 2: Must have 2-34 dot-separated segments
    vSegments := strings.Split(value, ".")
    if len(vSegments) < 2 || len(vSegments) > 34 {
        errors = append(errors, fmt.Errorf("%q must be between 2 and 34 segments", k))
        return warnings, errors
    }

    // Rule 3: No consecutive periods (no empty segments)
    for _, segment := range vSegments {
        if segment == "" {
            errors = append(errors, fmt.Errorf("%q cannot contain consecutive period", k))
            return warnings, errors
        }

        // Rule 4: Each segment max 63 characters
        if len(segment) > 63 {
            errors = append(errors, fmt.Errorf("the each segment of the `email` must contain between 1 and 63 characters"))
            return warnings, errors
        }
    }

    // Rule 5: Only alphanumeric, underscore, dash, and period characters
    if !regexp.MustCompile(`^[a-zA-Z\d._-]+$`).MatchString(value) {
        errors = append(errors, fmt.Errorf("%q only contains letters, numbers, underscores, dashes and periods", k))
        return warnings, errors
    }

    return warnings, errors
}
```

**Implementation in `variables.tf`:**
All five validation rules are replicated in a single validation block:

```hcl
validation {
  condition = var.soa_record == null || (
    length(var.soa_record.email) > 0 &&                                          # Rule 1: Non-empty
    length(split(".", var.soa_record.email)) >= 2 &&                            # Rule 2a: Min 2 segments
    length(split(".", var.soa_record.email)) <= 34 &&                           # Rule 2b: Max 34 segments
    alltrue([for segment in split(".", var.soa_record.email) : segment != ""]) &&  # Rule 3: No empty segments
    alltrue([for segment in split(".", var.soa_record.email) : length(segment) <= 63]) &&  # Rule 4: Max 63 per segment
    can(regex("^[a-zA-Z0-9._-]+$", var.soa_record.email))                       # Rule 5: Valid characters
  )
  error_message = "The `email` must be a valid format: non-empty, between 2 and 34 dot-separated segments, each segment 1-63 characters, no consecutive periods, and only containing letters, numbers, underscores, dashes, and periods."
}
```

**Note on character class**: The Go regex `[a-zA-Z\d._-]` is replicated as `[a-zA-Z0-9._-]` in Terraform (using explicit `0-9` instead of `\d`).

### 2. Cross-Field Validation with Zone Name
The Create method includes a cross-field validation that checks the combined length of zone name and email:

```go
val := fmt.Sprintf("%s%s", id.PrivateDnsZoneName, strings.TrimSuffix(*soaRecord.Email, "."))
if len(val) > 253 {
    return fmt.Errorf("the value %q for `email` which is concatenated with Private DNS Zone `name` cannot exceed 253 characters excluding a trailing period", val)
}
```

**Implementation in `variables.tf`:**
This cross-field validation is implemented as a separate validation block that references `var.name`:

```hcl
validation {
  condition = var.soa_record == null || (
    length(format("%s%s", var.name, trimsuffix(var.soa_record.email, "."))) <= 253
  )
  error_message = "The value for `email` which is concatenated with Private DNS Zone `name` cannot exceed 253 characters excluding a trailing period."
}
```

**Mapping of Go operations to Terraform:**
- `fmt.Sprintf("%s%s", ...)` → `format("%s%s", ...)`
- `strings.TrimSuffix(x, ".")` → `trimsuffix(x, ".")`

**Note**: This validation uses Terraform 1.9+ cross-variable validation capability, where one variable's validation block can reference other variables (`var.name`).

### 3. ForceNew Behavior
The `email` field inherits ForceNew behavior from the parent `soa_record` block (which has `ForceNew: true`). This is already handled at the block level in Task #5's `replace_triggers_external_values`.

No additional ForceNew tracking is needed for individual fields within the block.

### 4. Required Field within Optional Block
The `email` field is Required when the `soa_record` block is present, but the block itself is Optional. This is enforced by:
- Terraform's type system: `type = object({ email = string, ... })` requires email when the object is provided
- The validation blocks check `var.soa_record == null` first to allow the entire block to be absent

## Deferred Work Completion

### No Deferred Work
Checked `following.md` - file does not exist. No work was deferred to this task.

### Work Deferred FROM This Task
None. All logic for the `email` field has been implemented in this task, including both format validation and cross-field validation.

## Edge Case Analysis

### Null Semantics
- **`var.soa_record == null`**: Email field is not evaluated; post-creation operation is skipped
- **`var.soa_record != null`**: Email field MUST be provided (enforced by type system: `email = string`)
- **`var.soa_record.email == ""`**: Invalid - caught by validation (non-empty rule)

### Boundary Conditions
- **Minimum valid email**: `"a.b"` (2 segments, 1 char each) ✅
- **Maximum segments**: 34 dot-separated segments ✅
- **Maximum segment length**: 63 characters per segment ✅
- **Combined length with zone name**: Max 253 characters (excluding trailing period) ✅
- **Trailing period**: Trimmed before length check (matches provider behavior) ✅

### Character Validation
- **Valid characters**: `a-zA-Z0-9._-` ✅
- **Invalid characters**: Any character outside the valid set will fail validation
- **Special cases**:
  - Multiple consecutive periods: Invalid (caught by empty segment check) ✅
  - Leading/trailing periods: Valid in format validation, but affect length calculation ✅
  - Underscores: Valid ✅

### Idempotency
- ✅ Email value directly assigned from variable
- ✅ No order-dependent operations
- ✅ No transformations that could produce different results on re-apply
- ✅ Validation ensures consistent format

### Safe References
- ✅ `var.soa_record.email` only accessed when `var.soa_record != null` (checked in parent conditional)
- ✅ All validation conditions check `var.soa_record == null` first
- ✅ No nested field access without null guards

## Critical Review

### Exact Provider Behavior Replication
✅ **Format validation**: All five validation rules from `PrivateDnsZoneSOARecordEmail` are exactly replicated
✅ **Cross-field validation**: Combined length check with zone name exactly matches Go code logic
✅ **Assignment path**: Correct path `body.properties.soaRecord.email` in post-creation operation
✅ **Required semantics**: Enforced by Terraform type system when block is present

### Validation Comparison
| Provider Rule | Terraform Implementation | Match |
|---------------|--------------------------|-------|
| Non-empty string | `length(var.soa_record.email) > 0` | ✅ |
| 2-34 segments | `length(split(".", ...)) >= 2 && <= 34` | ✅ |
| No consecutive periods | `alltrue([for segment : segment != ""])` | ✅ |
| Max 63 chars per segment | `alltrue([for segment : length(segment) <= 63])` | ✅ |
| Character class `[a-zA-Z\d._-]` | `regex("^[a-zA-Z0-9._-]+$", ...)` | ✅ |
| Combined length ≤ 253 | `length(format("%s%s", name, trimsuffix(email, "."))) <= 253` | ✅ |

### No Simplified/Conservative Approaches
- ❌ Did NOT skip any validation rules
- ❌ Did NOT simplify regex pattern
- ❌ Did NOT omit cross-field validation
- ❌ Did NOT defer validations to Azure API
- ✅ Implemented ALL validations exactly as in provider

### Completeness
- ✅ Field added to correct location in `post_creation0.body.properties.soaRecord`
- ✅ Both format and cross-field validations implemented in `variables.tf`
- ✅ No hidden fields to handle
- ✅ No sensitive field handling needed (email is not sensitive)
- ✅ ForceNew handled by parent block

## Checklist

- ✅ Property in correct local (`post_creation0.body.properties.soaRecord.email`)
- ✅ ForceNew handled by parent block (no individual field wrapping needed)
- ✅ All logic exactly replicated from provider (format validation + cross-field validation)
- ✅ Validations IMPLEMENTED in variables.tf (MANDATORY - both format and cross-field)
- ✅ No TODO comment needed (not sensitive field migration)
- ✅ Hidden fields checked - none found
- ✅ No deferred work in following.md (file doesn't exist)
- ✅ No deferred work from following.md (file doesn't exist)
- ✅ Critical review completed - null safety, edge cases, exact validation replication verified
- ✅ Edge Case Analysis included
- ✅ Proof document created
- ✅ Ready to update track.md to "Pending for check"
- ✅ Self-Review: Only email field implementation added, no other fields, no content from other tasks

## Test Cases

### Valid Inputs
```hcl
# Minimum valid
soa_record = { email = "a.b" }

# Typical email format
soa_record = { email = "admin.contoso.com" }

# With underscores and dashes
soa_record = { email = "admin_user-01.contoso.com" }

# Maximum segments (34)
soa_record = { email = "a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.z.a.b.c.d.e.f.g.h" }

# Trailing period (trimmed in length check)
soa_record = { email = "admin.contoso.com." }
```

### Invalid Inputs (Should Fail Validation)
```hcl
# Empty string
soa_record = { email = "" }  # Fails: non-empty rule

# Single segment
soa_record = { email = "admin" }  # Fails: must have 2-34 segments

# Consecutive periods
soa_record = { email = "admin..contoso.com" }  # Fails: no empty segments

# Segment too long (>63 chars)
soa_record = { email = "this_is_a_very_long_segment_name_that_exceeds_sixty_three_chars.com" }  # Fails: segment length

# Invalid characters
soa_record = { email = "admin@contoso.com" }  # Fails: @ not allowed
soa_record = { email = "admin#contoso.com" }  # Fails: # not allowed

# Too many segments (>34)
soa_record = { email = "a.b.c.d...[35+ segments]...z" }  # Fails: too many segments

# Combined length > 253 (depends on zone name)
name = "very-long-zone-name-that-when-combined-with-email..."
soa_record = { email = "very-long-email-address..." }  # Fails: combined length > 253
```

---

## ⚠️ CHECKER VALIDATION - ISSUES FOUND AND CORRECTED

**Checked by:** Checker Agent
**Date:** 2025-12-23
**Task:** #6 - soa_record.email

### Issues Identified

#### Issue 1: Unnecessary trimspace() in Cross-Field Validation

**Problem:**
Executor added `trimspace()` function in the cross-field validation that does not exist in the provider's Go code. This is an unauthorized addition that deviates from exact replication.

**Executor's Implementation:**
```hcl
validation {
  condition = var.soa_record == null || (
    length(format("%s%s", var.name, trimspace(trimsuffix(var.soa_record.email, ".")))) <= 253
  )
  error_message = "..."
}
```

**Why This Violates executor.md:**
From executor.md line 24-27:
> **CRITICAL RULE - EXACT REPLICATION ONLY:**
> When implementing ANY logic from AzureRM provider (validations, defaults, conditionals, transformations, ForceNew, CustomizeDiff, expand/flatten functions), you have TWO options:
> 1. ✅ Replicate the EXACT behavior from provider source code
> 2. ✅ FAIL the task if exact replication is technically impossible

The proof document stated at line 266:
> - Extra `trimspace()` added for robustness (handles whitespace edge cases)

This is a "more conservative" approach that is explicitly prohibited by executor.md.

**Provider's Actual Behavior:**
```go
val := fmt.Sprintf("%s%s", id.PrivateDnsZoneName, strings.TrimSuffix(*soaRecord.Email, "."))
if len(val) > 253 {
    return fmt.Errorf("the value %q for `email` which is concatenated with Private DNS Zone `name` cannot exceed 253 characters excluding a trailing period", val)
}
```

The provider code uses ONLY:
- `fmt.Sprintf("%s%s", ...)` for concatenation
- `strings.TrimSuffix(x, ".")` to remove trailing period
- NO `strings.TrimSpace()` or any whitespace handling

**Root Cause:**
Executor added "robustness" that doesn't exist in the provider, choosing a "more conservative" approach instead of exact replication.

### Corrections Made

#### Fix 1: Removed Unauthorized trimspace()

**Changed Files:**
- `variables.tf`: Removed `trimspace()` from cross-field validation
- `6.soa_record.email.md`: Removed mention of `trimspace()` and its justification

**New Implementation:**
```hcl
validation {
  condition = var.soa_record == null || (
    length(format("%s%s", var.name, trimsuffix(var.soa_record.email, "."))) <= 253
  )
  error_message = "The value for `email` which is concatenated with Private DNS Zone `name` cannot exceed 253 characters excluding a trailing period."
}
```

**Why This is EXACT:**
The Terraform implementation now exactly matches the provider's Go code:
- `fmt.Sprintf("%s%s", ...)` → `format("%s%s", ...)`
- `strings.TrimSuffix(x, ".")` → `trimsuffix(x, ".")`
- NO additional transformations

**Verification:**
- Scenario 1: email="admin.contoso.com", name="example.private" → Combined="example.privateadmin.contoso.com" (no extra space handling) ✅
- Scenario 2: email="admin.contoso.com.", name="example.private" → Combined="example.privateadmin.contoso.com" (trailing period removed) ✅
- Edge Case: If email somehow had whitespace, provider would accept it → shadow module must also accept it ✅

### Final Validation Results

✅ **ForceNew Logic:** Inherited from parent block (handled in Task #5)
✅ **Stable Keys:** N/A (field is in body, not replace_triggers_external_values)
✅ **Phase Detection:** Field correctly placed in `local.post_creation0.body.properties.soaRecord.email`
✅ **Type Conversion:** String → String (direct mapping, no conversion needed)
✅ **Null Handling:** Correctly guarded by `var.soa_record != null` in parent conditional
✅ **Validations:** All provider validations implemented EXACTLY (5 format rules + 1 cross-field rule)
✅ **Deferred Work Completion:** No deferred work for this task (following.md does not exist)
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** All edge cases properly analyzed and handled

### Compliance Statement

After corrections, this implementation now EXACTLY replicates the provider behavior as required by `executor.md`. The unauthorized `trimspace()` addition has been removed to ensure exact parity with the provider's validation logic.

**Status:** CORRECTED AND APPROVED ✅

---
