# Task #1 - `name` Argument Migration

## Summary
Migrated the root-level `name` argument from `azurerm_private_dns_zone` to `azapi_resource`. The field is Required and ForceNew, used in the `azapi_header` and tracked in `replace_triggers_external_values`.

## Shadow Implementation

```hcl
# migrate_main.tf
locals {
  azapi_header = {
    type                 = "Microsoft.Network/privateDnsZones@2024-06-01"  # <-
    name                 = var.name  # <-
    location             = "global"  # <-
    parent_id            = var.resource_group_id  # <-
    tags                 = var.tags  # <-
    ignore_null_property = true  # <-
    retry                = null  # <-
  }

  replace_triggers_external_values = {
    name = { value = var.name }  # <-
  }
}
```

```hcl
# migrate_variables.tf
variable "resource_group_id" {  # <-
  type        = string  # <-
  description = "(Required) The ID of the Resource Group where the Private DNS Zone should exist."  # <-
  nullable    = false  # <-
}  # <-
```

## Create Phase Verification

### Query Create Method
Queried the Create method using `query_terraform_block_implementation_source_code(block_type="resource", terraform_type="azurerm_private_dns_zone", entrypoint_name="create")`.

### Pattern Identification
The Create method follows a **single-phase pattern**:

```go
func resourcePrivateDnsZoneCreateUpdate(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).PrivateDns.PrivateZonesClient
	// ...
	id := privatezones.NewPrivateDnsZoneID(subscriptionId, d.Get("resource_group_name").(string), d.Get("name").(string))
	// ...
	parameters := privatezones.PrivateZone{
		Location: pointer.To("global"),
		Tags:     tags.Expand(d.Get("tags").(map[string]interface{})),
	}
	
	options := privatezones.CreateOrUpdateOperationOptions{
		IfMatch:     pointer.To(""),
		IfNoneMatch: pointer.To(""),
	}
	
	if err := client.CreateOrUpdateThenPoll(ctx, id, parameters, options); err != nil {
		return fmt.Errorf("creating/updating %s: %s", id, err)
	}
	// ... SOA record handling after zone creation ...
}
```

### Field Classification
- **Phase**: Create phase (before the `CreateOrUpdateThenPoll` call)
- **Usage**: The `name` field is retrieved via `d.Get("name").(string)` at line where the ID is constructed
- **Decision**: Add to `azapi_header.name` (not in `body` since `name` is a top-level azapi_resource parameter)

## Assignment Path Verification

### Predicted Path
`azapi_header.name` (top-level parameter, not in body)

### Go Code Evidence
```go
id := privatezones.NewPrivateDnsZoneID(subscriptionId, d.Get("resource_group_name").(string), d.Get("name").(string))
// ...
if err := client.CreateOrUpdateThenPoll(ctx, id, parameters, options); err != nil {
```

The `name` is used to construct the resource ID, which is then passed to the API. It's not part of the request body (`parameters` struct only has `Location` and `Tags`).

### Verified Path
`azapi_header.name`

### Path Comparison
✅ **Match** - The `name` is a top-level resource identifier, not a body property.

## Provider Schema

From the schema query result:

```go
"name": {
	Type:     pluginsdk.TypeString,
	Required: true,
	ForceNew: true,
},
```

**Key Properties:**
- **Type**: String
- **Required**: true
- **ForceNew**: true (requires resource replacement when changed)
- **Validation**: None (no ValidateFunc specified)

## Azure API Schema

The Azure API documentation shows `name` is a top-level deployment-time constant:

```json
{
  "name": "The resource name (Required) (DeployTimeConstant)"
}
```

The `name` is NOT in the request body - it's part of the resource identifier in the API path:
`/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}`

## Hidden Fields

**No hidden fields detected** for the `name` argument. The `location` field is hardcoded as "global" in the provider:

```go
parameters := privatezones.PrivateZone{
	Location: pointer.To("global"),
	Tags:     tags.Expand(d.Get("tags").(map[string]interface{})),
}
```

The `location` is included in `azapi_header` but is not a "hidden field" in the context of this task - it will be handled by the parent initialization.

## Mapping

| AzureRM Field | AzAPI Field | Notes |
|---------------|-------------|-------|
| `name` | `azapi_header.name` | Direct mapping, top-level parameter |

## Special Handling

### ForceNew
The `name` field has `ForceNew: true` in the provider schema, which means changing the name forces a new resource to be created. 

**Implementation:**
```hcl
replace_triggers_external_values = {
  name = { value = var.name }
}
```

The field is wrapped in an object with a `value` key to ensure the key remains stable across applies (as per executor.md requirements).

### Validation
No validation is specified in the provider schema for the `name` field. Azure DNS zone names follow DNS naming conventions, but the provider does not enforce specific validation rules beyond what Azure API enforces.

**Decision:** No validation block added to `variables.tf` since the provider schema doesn't specify validation.

### Parent ID
As Task #1, I created the `resource_group_id` variable in `migrate_variables.tf` to be used in `parent_id`. This will be populated by Task #2 (resource_group_name conversion).

## Critical Review & Edge Case Analysis

### Null Semantics
- **Input**: `var.name` is `nullable = false` in `variables.tf`, so it cannot be null
- **Behavior**: Always present, no null handling needed

### Boundary Conditions
- **Empty string**: Not validated by provider, will be caught by Azure API
- **Special characters**: DNS naming rules apply, Azure API will validate
- **Length**: DNS zone names have maximum length, Azure API will validate

### Idempotency
- **Stable**: The `name` value is directly passed without transformation
- **No order dependence**: Single value, no array operations

### Safe References
- **Direct reference**: `var.name` is always non-null per schema definition
- **No nested access**: Top-level variable, no null checks needed

## Checklist

- ✅ Property in correct local (`azapi_header.name`)
- ✅ ForceNew wrapped: `{ value = var.name }` in `replace_triggers_external_values`
- ✅ All logic exactly replicated from provider (simple direct assignment, no additional logic)
- ✅ Validations: None required (provider has no validation for name)
- ✅ Hidden fields checked (none for name specifically; location is hardcoded)
- ✅ Deferred work in following.md: N/A (no cross-field dependencies)
- ✅ Deferred work from following.md: N/A (first task)
- ✅ Critical review completed (null, edge, idempotent, safe refs)
- ✅ Edge Case Analysis in proof
- ✅ Proof created
- ✅ `track.md` will be updated to Pending for check
- ✅ Self-Review: Only implemented name field and azapi_header setup (Task #1 scope)

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-22
**Task:** #1 - name

### Validation Results

✅ **Complete azapi_header Initialization:** All required fields properly set (type, name, location, parent_id, tags, ignore_null_property, retry)
✅ **terraform.tf Created:** AzAPI provider version constraint (~> 2.0) correctly specified
✅ **ForceNew Logic:** Simple ForceNew correctly implemented with stable key wrapper `{ value = var.name }`
✅ **Stable Keys:** Key `name` always present in `replace_triggers_external_values`
✅ **Phase Detection:** Field correctly placed in `azapi_header` (top-level parameter, not body)
✅ **Type Conversion:** Direct string mapping, no conversion needed
✅ **Null Handling:** Variable defined as `nullable = false`, correctly enforces non-null
✅ **Validations:** None required per provider schema (no ValidateFunc specified)
✅ **Deferred Work Completion:** No deferred work for this task (first task)
✅ **Deferred Work Recording:** No deferrals made (no cross-field dependencies)
✅ **Edge Cases:** Properly analyzed - null semantics, boundary conditions, idempotency, safe references
✅ **resource_group_id Variable:** Correctly created in migrate_variables.tf with proper type and nullable = false
✅ **Initial Template Structure:** All required locals properly initialized (body, sensitive_body, sensitive_body_version, post_creation_updates, locks)
✅ **Outputs Structure:** All required outputs properly defined in migrate_outputs.tf

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The implementation:
- Correctly places `name` in `azapi_header` (not in body, as it's a top-level resource identifier)
- Properly implements ForceNew tracking using the stable key pattern
- Creates the complete azapi_header structure as specified for Task #1
- Creates the terraform.tf file with AzAPI 2.0+ version constraint
- Initializes all required local structures for future tasks
- Creates resource_group_id variable for parent_id usage

No deviations, simplifications, or "safer alternatives" were found.

**Status:** APPROVED ✅

---
