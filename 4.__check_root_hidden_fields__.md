# Task #4 - Check Root Hidden Fields

## Summary

Verified the provider's Create method for hidden fields in the root properties block. The provider creates a Private DNS Zone with **NO properties in the request body** - only `location` (hardcoded as "global") and `tags` are set at the root level. All properties in the Azure API schema are ReadOnly (computed). The SOA record is handled separately via a different API endpoint after zone creation. No locks are used in any CRUD methods. The existing `local.body.properties = {}` is correct and requires no modifications.

## Create Phase Verification

### Pattern Identification

**Pattern:** Single-phase creation

**Evidence from Create Method:**

```go
func resourcePrivateDnsZoneCreateUpdate(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).PrivateDns.PrivateZonesClient
	recordSetsClient := meta.(*clients.Client).PrivateDns.RecordSetsClient
	// ...
	
	parameters := privatezones.PrivateZone{
		Location: pointer.To("global"),
		Tags:     tags.Expand(d.Get("tags").(map[string]interface{})),
	}

	options := privatezones.CreateOrUpdateOperationOptions{
		IfMatch:     pointer.To(""),
		IfNoneMatch: pointer.To(""),
	}

	if err := client.CreateOrUpdateThenPoll(ctx, id, parameters, options); err != nil {
		return fmt.Errorf("creating/updating %s: %s", id, err)
	}
	
	// SOA record is handled separately after zone creation (not part of zone body)
	if v, ok := d.GetOk("soa_record"); ok {
		// ... separate API call to recordSetsClient.RecordSetsCreateOrUpdate
	}
```

**Analysis:**
- The provider constructs a `privatezones.PrivateZone` struct with only `Location` and `Tags`
- No `Properties` field is set on the `parameters` struct
- The zone is created with `client.CreateOrUpdateThenPoll(ctx, id, parameters, options)` - single phase
- SOA record configuration (if provided) is handled AFTER zone creation via a separate API call to a different endpoint (`RecordSetsCreateOrUpdate`)

**Decision:** This is a single-phase creation. The zone body contains NO properties.

## Assignment Path Verification

### Root Level Fields

**Field: location**

**Predicted Path:** Root-level field (not in body.properties)

**Go Code Evidence:**
```go
parameters := privatezones.PrivateZone{
	Location: pointer.To("global"),  // <- Hardcoded value
	Tags:     tags.Expand(d.Get("tags").(map[string]interface{})),
}
```

**Verified Path:** Root level `location` field

**Path Comparison:** ✅ Match - `location` is a root-level field in `azapi_resource`, already correctly placed in `local.azapi_header.location = "global"`

**Field: tags**

**Predicted Path:** Root-level field (not in body.properties)

**Go Code Evidence:**
```go
parameters := privatezones.PrivateZone{
	Location: pointer.To("global"),
	Tags:     tags.Expand(d.Get("tags").(map[string]interface{})),  // <- Tags at root
}
```

**Verified Path:** Root level `tags` field

**Path Comparison:** ✅ Match - `tags` is a root-level field in `azapi_resource`, already correctly placed in `local.azapi_header.tags = var.tags`

### Body Properties Analysis

**Predicted Path:** `body.properties` should be empty

**Go Code Evidence:**
```go
// NO Properties field is set on the parameters struct
parameters := privatezones.PrivateZone{
	Location: pointer.To("global"),
	Tags:     tags.Expand(d.Get("tags").(map[string]interface{})),
	// NOTE: No Properties field assignment here
}
```

**Azure API Schema Evidence:**
```
"properties": {
  "internalId": "Private zone internal Id (ReadOnly)",
  "maxNumberOfRecordSets": "... (ReadOnly)",
  "maxNumberOfVirtualNetworkLinks": "... (ReadOnly)",
  "maxNumberOfVirtualNetworkLinksWithRegistration": "... (ReadOnly)",
  "numberOfRecordSets": "... (ReadOnly)",
  "numberOfVirtualNetworkLinks": "... (ReadOnly)",
  "numberOfVirtualNetworkLinksWithRegistration": "... (ReadOnly)",
  "provisioningState": "... (ReadOnly)"
}
```

**Analysis:**
- All properties in the Azure API schema are marked as `ReadOnly`
- The provider does NOT set any properties field on the request struct
- The properties object is entirely computed by Azure after creation

**Verified Path:** `body.properties` = `{}`

**Path Comparison:** ✅ Match - The existing implementation in `migrate_main.tf` with `properties = {}` is correct

## Provider Schema

Not applicable - this task is checking for hidden fields NOT in the schema.

## Azure API Schema

**Resource Type:** `Microsoft.Network/privateDnsZones@2024-06-01`

**Body Structure:**
```json
{
  "location": "global",
  "tags": {},
  "properties": {
    // All fields are ReadOnly - computed by Azure
  }
}
```

**Properties Fields (All ReadOnly):**
- `internalId` - Private zone internal Id (ReadOnly)
- `maxNumberOfRecordSets` - Max record sets (ReadOnly)
- `maxNumberOfVirtualNetworkLinks` - Max VNet links (ReadOnly)
- `maxNumberOfVirtualNetworkLinksWithRegistration` - Max VNet links with registration (ReadOnly)
- `numberOfRecordSets` - Current record sets count (ReadOnly)
- `numberOfVirtualNetworkLinks` - Current VNet links count (ReadOnly)
- `numberOfVirtualNetworkLinksWithRegistration` - Current VNet links with registration count (ReadOnly)
- `provisioningState` - Provisioning state (ReadOnly)

## Hidden Fields

**Hidden Field: location = "global"**

**Evidence:**
```go
parameters := privatezones.PrivateZone{
	Location: pointer.To("global"),  // <- Hardcoded to "global"
	Tags:     tags.Expand(d.Get("tags").(map[string]interface{})),
}
```

**Analysis:**
- The provider hardcodes `location` to `"global"` for all Private DNS zones
- This is NOT a schema field - it's set directly in the Create method
- Already correctly handled in `migrate_main.tf` as `local.azapi_header.location = "global"`

**Hidden Fields in body.properties: NONE**

**Evidence:**
- The provider does NOT assign a `Properties` field to the `parameters` struct
- All properties in the Azure API schema are `ReadOnly` (computed)
- No hidden properties need to be added to `local.body.properties`

## SOA Record Handling

**Note:** The `soa_record` block is NOT part of the zone creation body. It's handled via a separate API call after zone creation:

```go
if v, ok := d.GetOk("soa_record"); ok {
	soaRecordRaw := v.([]interface{})[0].(map[string]interface{})
	soaRecord := expandPrivateDNSZoneSOARecord(soaRecordRaw)
	rsParameters := privatedns.RecordSet{
		Properties: &privatedns.RecordSetProperties{
			Ttl:       pointer.To(int64(soaRecordRaw["ttl"].(int))),
			Metadata:  tags.Expand(soaRecordRaw["tags"].(map[string]interface{})),
			SoaRecord: soaRecord,
		},
	}

	recordId := privatedns.NewRecordTypeID(id.SubscriptionId, id.ResourceGroupName, id.PrivateDnsZoneName, privatedns.RecordTypeSOA, "@")
	
	if _, err := recordSetsClient.RecordSetsCreateOrUpdate(ctx, recordId, rsParameters, createOptions); err != nil {
		return fmt.Errorf("creating/updating %s: %s", recordId, err)
	}
}
```

This separate API call will be handled in Task #5 (soa_record block).

## Locks Detection

### Search in Create Method

**Pattern Search:** Looking for `locks.ByName`, `locks.MultipleByName`, or similar lock patterns

**Evidence from Create:**
```go
func resourcePrivateDnsZoneCreateUpdate(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).PrivateDns.PrivateZonesClient
	recordSetsClient := meta.(*clients.Client).PrivateDns.RecordSetsClient
	// ... no lock calls found
	
	if err := client.CreateOrUpdateThenPoll(ctx, id, parameters, options); err != nil {
		return fmt.Errorf("creating/updating %s: %s", id, err)
	}
	// ... no lock calls found
}
```

**Result:** No locks in Create method

### Search in Update Method

Update uses the same function as Create (`resourcePrivateDnsZoneCreateUpdate`)

**Result:** No locks in Update method

### Search in Delete Method

**Evidence from Delete:**
```go
func resourcePrivateDnsZoneDelete(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).PrivateDns.PrivateZonesClient
	ctx, cancel := timeouts.ForDelete(meta.(*clients.Client).StopContext, d)
	defer cancel()

	id, err := privatezones.ParsePrivateDnsZoneID(d.Id())
	if err != nil {
		return err
	}

	options := privatezones.DeleteOperationOptions{IfMatch: pointer.To("")}

	if err = client.DeleteThenPoll(ctx, *id, options); err != nil {
		return fmt.Errorf("deleting %s: %+v", *id, err)
	}

	return nil
}
```

**Result:** No locks in Delete method

### Conclusion

**Locks:** `[]` (empty list)

No lock patterns were found in any CRUD methods. The resource does not use resource locking.

## Mapping

No field name mapping required - this task verifies hidden fields only.

## Special Handling

**None Required**

- No hidden fields need to be added to `local.body.properties`
- The existing `properties = {}` is correct and matches provider behavior
- `location` is already correctly handled in `local.azapi_header.location = "global"`
- `tags` is already correctly handled in `local.azapi_header.tags = var.tags`
- `locks` remain empty `[]`

## Implementation

### Current migrate_main.tf (No Changes Required)

```hcl
locals {
  azapi_header = {
    type                 = "Microsoft.Network/privateDnsZones@2024-06-01"
    name                 = var.name
    location             = "global"  # <- Already correct (hardcoded)
    parent_id            = var.resource_group_id
    tags                 = var.tags  # <- Already correct
    ignore_null_property = true
    retry                = null
  }

  replace_triggers_external_values = {
    name = { value = var.name }
  }

  body = {
    properties = {}  # <- Already correct (no properties in provider)
  }

  sensitive_body = {
    properties = {}
  }

  sensitive_body_version = {}

  post_creation_updates = compact([])

  locks = []  # <- Already correct (no locks in provider)
}
```

**Analysis:** The current implementation is already correct:
- ✅ `location = "global"` is in `azapi_header` (matches provider hardcoded value)
- ✅ `tags = var.tags` is in `azapi_header` (matches provider behavior)
- ✅ `body.properties = {}` is empty (matches provider - no properties set)
- ✅ `locks = []` is empty (matches provider - no locks used)

**Conclusion:** No modifications needed. The hidden field check is complete and all values are correctly implemented.

## Edge Case Analysis

### Null Semantics
- **location:** Always "global" - no null case possible
- **tags:** Handled by `var.tags` which can be null/empty - provider expands to empty map
- **properties:** Always empty object - no nullable properties to consider

### Boundary Conditions
- **Empty zone:** Valid - zones can exist with no properties (all computed)
- **No tags:** Valid - tags are optional
- **Properties validation:** Not applicable - all properties are ReadOnly and computed by Azure

### Idempotency
- **location:** Always "global" - idempotent
- **tags:** Handled by azapi_resource tag merging - idempotent
- **properties:** Empty object - idempotent

### Safe References
- No nested property access required - all fields are at root or empty
- No conditional logic needed for property construction

## Deferred Work Completion

Checked `following.md` - file does not exist yet. No deferred work to complete.

## Checklist

- ✅ Property in correct local: `location` in `azapi_header`, `properties` in `body`
- ✅ ForceNew wrapped: Not applicable (no ForceNew fields added)
- ✅ ALL logic EXACTLY replicated from provider: Yes - empty properties matches provider exactly
- ✅ Validations IMPLEMENTED: Not applicable (no validations for computed-only properties)
- ✅ TODO comment added: Not applicable (no sensitive fields migrated)
- ✅ Hidden fields checked: Yes - `location="global"` already in `azapi_header`, no properties to add
- ✅ Deferred work in following.md: Not applicable (no work deferred)
- ✅ Deferred work from following.md: Not applicable (file doesn't exist)
- ✅ Critical review: Complete - null semantics, edge cases, idempotency verified
- ✅ Edge Case Analysis in proof: Complete
- ✅ Proof created: This document
- ✅ `track.md` updated to Pending for check: Next step
- ✅ Self-Review: Task only checks hidden fields - no other task content added

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-22
**Task:** #4 - __check_root_hidden_fields__

### Validation Results

✅ **Hidden Fields Detection:** Correctly identified that provider sets NO properties in request body. Only `location="global"` (already in azapi_header) and `tags` (already in azapi_header) are set at root level.
✅ **Body Properties:** Correctly verified that `body.properties = {}` matches provider behavior exactly - provider does NOT assign a Properties field to the request struct.
✅ **Azure API Schema Analysis:** All properties fields are ReadOnly/computed - confirmed with Azure API schema evidence.
✅ **Locks Detection:** Comprehensively checked all CRUD methods (Create, Update, Delete) - no lock patterns found. `locks = []` is correct.
✅ **Two-Phase Check:** Correctly identified single-phase creation pattern.
✅ **Assignment Path Verification:** Correctly traced that only `Location` and `Tags` are set on the `parameters` struct, with no `Properties` field assignment.
✅ **SOA Record Handling:** Correctly identified that `soa_record` is handled via separate API call after zone creation (will be Task #5).
✅ **Implementation Status:** No changes required - existing implementation already correct.
✅ **Deferred Work Completion:** No deferred work (following.md doesn't exist yet).
✅ **Edge Cases:** Properly analyzed null semantics, boundary conditions, and idempotency.

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The executor correctly identified that:
1. The provider sends NO properties in the Private DNS Zone creation request body
2. All properties in the Azure API are ReadOnly and computed by Azure
3. Only `location` (hardcoded to "global") and `tags` are set at root level
4. No locks are used in any CRUD methods

The existing `local.body.properties = {}` is correct and requires no modifications. No deviations, simplifications, or "safer alternatives" were found.

**Status:** APPROVED ✅

---
