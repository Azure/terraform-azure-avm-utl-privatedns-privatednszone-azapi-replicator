# Task #5 - soa_record Block Structure Skeleton

## Summary
Created the structure skeleton for the `soa_record` block, which is implemented as a post-creation operation (`post_creation0`) using a separate API call to `Microsoft.Network/privateDnsZones/SOA@2024-06-01` after the primary zone creation. The block is ForceNew and contains placeholders for 7 child arguments (Tasks #6-12).

## Shadow Implementation
```hcl
locals {
  # <- ForceNew tracking for soa_record block existence
  replace_triggers_external_values = {
    name       = { value = var.name }
    soa_record = { value = var.soa_record != null ? true : null } # <-
  }

  # <- Post-creation operation for SOA record
  post_creation0 = var.soa_record != null ? { # <-
    azapi_header = { # <-
      type = "Microsoft.Network/privateDnsZones/SOA@2024-06-01" # <-
    }
    body = { # <-
      properties = merge( # <-
        { # <-
          # ttl = ... # Task #11 # <-
        }, # <-
        var.soa_record != null ? { # <-
          soaRecord = { # <-
            # email = ... # Task #6 # <-
            # expireTime = ... # Task #7 # <-
            # minimumTtl = ... # Task #8 # <-
            # refreshTime = ... # Task #9 # <-
            # retryTime = ... # Task #10 # <-
          } # <-
          # metadata = ... # Task #12 # <-
        } : {} # <-
      ) # <-
    } # <-
    locks = local.locks # <-
  } : null # <-

  post_creation0_sensitive_body = var.soa_record != null ? { # <-
    properties = {} # <-
  } : null # <-
}

output "post_creation0" { # <-
  value = local.post_creation0 # <-
} # <-

output "post_creation0_sensitive_body" { # <-
  value     = local.post_creation0_sensitive_body # <-
  sensitive = true # <-
  ephemeral = true # <-
} # <-
```

## Create Phase Verification

### Pattern: Two-Phase Create
The `soa_record` block requires a two-phase creation pattern:
1. **Primary Create**: Create the Private DNS Zone (main resource)
2. **Post-Creation**: Update the SOA record via separate API call

### Evidence from Create Method
From `resourcePrivateDnsZoneCreateUpdate`:

```go
// Phase 1: Primary zone creation
if err := client.CreateOrUpdateThenPoll(ctx, id, parameters, options); err != nil {
    return fmt.Errorf("creating/updating %s: %s", id, err)
}

// Phase 2: SOA record post-creation operation
if v, ok := d.GetOk("soa_record"); ok {
    soaRecordRaw := v.([]interface{})[0].(map[string]interface{})
    soaRecord := expandPrivateDNSZoneSOARecord(soaRecordRaw)
    rsParameters := privatedns.RecordSet{
        Properties: &privatedns.RecordSetProperties{
            Ttl:       pointer.To(int64(soaRecordRaw["ttl"].(int))),
            Metadata:  tags.Expand(soaRecordRaw["tags"].(map[string]interface{})),
            SoaRecord: soaRecord,
        },
    }

    recordId := privatedns.NewRecordTypeID(id.SubscriptionId, id.ResourceGroupName, id.PrivateDnsZoneName, privatedns.RecordTypeSOA, "@")

    // Validation logic for email length
    val := fmt.Sprintf("%s%s", id.PrivateDnsZoneName, strings.TrimSuffix(*soaRecord.Email, "."))
    if len(val) > 253 {
        return fmt.Errorf("the value %q for `email` which is concatenated with Private DNS Zone `name` cannot exceed 253 characters excluding a trailing period", val)
    }

    createOptions := privatedns.RecordSetsCreateOrUpdateOperationOptions{
        IfMatch:     pointer.To(""),
        IfNoneMatch: pointer.To(""),
    }

    if _, err := recordSetsClient.RecordSetsCreateOrUpdate(ctx, recordId, rsParameters, createOptions); err != nil {
        return fmt.Errorf("creating/updating %s: %s", recordId, err)
    }
}
```

### SDK Function Classification
- **Primary Operation**: `client.CreateOrUpdateThenPoll()` - Creates Private DNS Zone
- **Post-Operation**: `recordSetsClient.RecordSetsCreateOrUpdate()` - **CreateOrUpdate** function
- **Classification**: Post-creation operation using CreateOrUpdate â†’ `post_creation0`
- **Index**: 0 (first and only post-operation in this resource)

### Decision
The `soa_record` block is implemented as `local.post_creation0` (not in `local.body`) because:
1. It's processed AFTER the primary zone creation
2. It uses a separate SDK client (`recordSetsClient`) with a different resource type
3. It targets a child resource: `Microsoft.Network/privateDnsZones/SOA` with relative name `@`

## Assignment Path Verification

### Predicted Path
`body.properties.soaRecord` for the SOA record properties
`body.properties.ttl` for the TTL value
`body.properties.metadata` for tags

### Go Code Evidence
```go
rsParameters := privatedns.RecordSet{
    Properties: &privatedns.RecordSetProperties{  // <-- Properties assignment
        Ttl:       pointer.To(int64(soaRecordRaw["ttl"].(int))),
        Metadata:  tags.Expand(soaRecordRaw["tags"].(map[string]interface{})),
        SoaRecord: soaRecord,  // <-- soaRecord nested under Properties
    },
}
```

From `expandPrivateDNSZoneSOARecord`:
```go
func expandPrivateDNSZoneSOARecord(input map[string]interface{}) *privatedns.SoaRecord {
    return &privatedns.SoaRecord{
        Email:       pointer.To(input["email"].(string)),
        ExpireTime:  pointer.To(int64(input["expire_time"].(int))),
        MinimumTtl:  pointer.To(int64(input["minimum_ttl"].(int))),
        RefreshTime: pointer.To(int64(input["refresh_time"].(int))),
        RetryTime:   pointer.To(int64(input["retry_time"].(int))),
    }
}
```

### Verified Path
1. `RecordSet` struct â†’ `.Properties` â†’ `RecordSetProperties` struct
2. Within `RecordSetProperties`:
   - `soaRecord` contains the SOA record fields
   - `ttl` is at the same level as `soaRecord`
   - `metadata` (maps to `tags` in schema) is at the same level

**Azure API Path**: `body.properties.soaRecord.*` for SOA fields, `body.properties.ttl`, `body.properties.metadata`

### Path Comparison
âœ… **Match**: The predicted and verified paths align. All SOA record properties go inside `properties.soaRecord`, while `ttl` and `metadata` are sibling properties at `properties.*`.

## Provider Schema

### Schema Definition
From the resource schema:
```go
"soa_record": {
    Type:     pluginsdk.TypeList,
    MaxItems: 1,
    Optional: true,
    Computed: true,
    ForceNew: true,  // <-- CRITICAL: Block is ForceNew
    Elem: &pluginsdk.Resource{
        Schema: map[string]*pluginsdk.Schema{
            "email": {
                Type:         pluginsdk.TypeString,
                Required:     true,
                ValidateFunc: validate.PrivateDnsZoneSOARecordEmail,
            },
            "expire_time": {
                Type:         pluginsdk.TypeInt,
                Optional:     true,
                Default:      2419200,
                ValidateFunc: validation.IntAtLeast(0),
            },
            "minimum_ttl": {
                Type:         pluginsdk.TypeInt,
                Optional:     true,
                Default:      10,
                ValidateFunc: validation.IntAtLeast(0),
            },
            "refresh_time": {
                Type:         pluginsdk.TypeInt,
                Optional:     true,
                Default:      3600,
                ValidateFunc: validation.IntAtLeast(0),
            },
            "retry_time": {
                Type:         pluginsdk.TypeInt,
                Optional:     true,
                Default:      300,
                ValidateFunc: validation.IntAtLeast(0),
            },
            "ttl": {
                Type:         pluginsdk.TypeInt,
                Optional:     true,
                Default:      3600,
                ValidateFunc: validation.IntBetween(0, math.MaxInt32),
            },
            "tags": commonschema.Tags(),
            // Computed fields omitted (fqdn, host_name, serial_number)
        },
    },
},
```

### Key Properties
- **Type**: List with MaxItems: 1 (treated as optional single object)
- **Optional**: true
- **Computed**: true (SOA record exists by default, can be customized)
- **ForceNew**: true (any change to SOA record requires resource replacement)
- **Child Arguments**: 7 arguments (email, expire_time, minimum_ttl, refresh_time, retry_time, ttl, tags)

## Azure API Schema

### SOA Record Type
Resource Type: `Microsoft.Network/privateDnsZones/SOA@2024-06-01`

### Property Path
`body.properties.soaRecord` with the following structure:
```json
{
  "email": "string (required)",
  "expireTime": "number (optional)",
  "minimumTtl": "number (optional)", 
  "refreshTime": "number (optional)",
  "retryTime": "number (optional)"
}
```

Additional properties at `body.properties` level:
- `ttl`: "number (optional)"
- `metadata`: "map[string]string (optional)" (maps to tags)

### Azure API Documentation
From Azure API for `soaRecord` properties:
- `email`: "The email contact for this SOA record."
- `expireTime`: "The expire time for this SOA record."
- `host`: "The domain name of the authoritative name server for this SOA record." (Computed)
- `minimumTtl`: "The minimum value for this SOA record. By convention this is used to determine the negative caching duration."
- `refreshTime`: "The refresh value for this SOA record."
- `retryTime`: "The retry time for this SOA record."
- `serialNumber`: "The serial number for this SOA record." (Computed)

## Hidden Fields Check

### Expand Function Analysis
From `expandPrivateDNSZoneSOARecord`:
```go
func expandPrivateDNSZoneSOARecord(input map[string]interface{}) *privatedns.SoaRecord {
    return &privatedns.SoaRecord{
        Email:       pointer.To(input["email"].(string)),
        ExpireTime:  pointer.To(int64(input["expire_time"].(int))),
        MinimumTtl:  pointer.To(int64(input["minimum_ttl"].(int))),
        RefreshTime: pointer.To(int64(input["refresh_time"].(int))),
        RetryTime:   pointer.To(int64(input["retry_time"].(int))),
    }
}
```

### Hidden Fields Found
**None** - The expand function only processes fields that are already in the schema. All fields map directly from schema to API:
- `email` â†’ `Email`
- `expire_time` â†’ `ExpireTime`
- `minimum_ttl` â†’ `MinimumTtl`
- `refresh_time` â†’ `RefreshTime`
- `retry_time` â†’ `RetryTime`

Note: `ttl` and `tags` (metadata) are not in the expand function because they're handled directly in the Create method at the `RecordSetProperties` level, not inside the `SoaRecord` struct.

## Mapping (snake_case â†’ camelCase)

| Schema Field (snake_case) | API Field (camelCase) | Notes |
|---------------------------|----------------------|-------|
| `soa_record` | `soaRecord` | Nested object in properties |
| `email` | `email` | No case change |
| `expire_time` | `expireTime` | |
| `minimum_ttl` | `minimumTtl` | |
| `refresh_time` | `refreshTime` | |
| `retry_time` | `retryTime` | |
| `ttl` | `ttl` | Property-level field |
| `tags` | `metadata` | Property-level field, name change |

## Special Handling

### 1. ForceNew Implementation
The entire `soa_record` block has `ForceNew: true`, meaning any change triggers resource replacement.

**Implementation in `replace_triggers_external_values`:**
```hcl
soa_record = { value = var.soa_record != null ? true : null }
```

**Rationale**: Track block presence (not individual field values) since entire block is ForceNew. When block exists (`!= null`), value is `true`; when absent, value is `null`. This ensures:
- Adding `soa_record` block triggers replacement
- Removing `soa_record` block triggers replacement
- Modifying any field within the block triggers replacement (due to block-level ForceNew)

### 2. Post-Creation Operation
The SOA record is created/updated via a separate API call after zone creation:

**Type**: `post_creation0` (first post-creation operation)
**Resource Type**: `Microsoft.Network/privateDnsZones/SOA@2024-06-01`
**Relative Name**: `@` (special name for SOA records in DNS)

**Structure**:
```hcl
post_creation0 = var.soa_record != null ? {
  azapi_header = {
    type = "Microsoft.Network/privateDnsZones/SOA@2024-06-01"
  }
  body = {
    properties = merge(
      { /* ttl placeholder */ },
      var.soa_record != null ? {
        soaRecord = { /* field placeholders */ }
        /* metadata placeholder */
      } : {}
    )
  }
  locks = local.locks
} : null
```

### 3. Conditional Structure
The entire post-creation operation is conditional based on `var.soa_record != null`:
- When `null`: `post_creation0` is `null` (no SOA record operation)
- When set: Full structure is created with placeholders for child tasks

### 4. Cross-Field Validation (Deferred)
From Create method:
```go
val := fmt.Sprintf("%s%s", id.PrivateDnsZoneName, strings.TrimSuffix(*soaRecord.Email, "."))
if len(val) > 253 {
    return fmt.Errorf("the value %q for `email` which is concatenated with Private DNS Zone `name` cannot exceed 253 characters excluding a trailing period", val)
}
```

This validation involves both `name` (Task #1) and `email` (Task #6). It will be **deferred to Task #6** (email field owner).

## Child Tasks Ready for Delegation

The following child tasks are now ready to be delegated since the block skeleton has been created:

| Task # | Field | Type | Notes |
|--------|-------|------|-------|
| **6** | `soa_record.email` | Argument | Required, has custom validation |
| **7** | `soa_record.expire_time` | Argument | Optional, Default: 2419200 |
| **8** | `soa_record.minimum_ttl` | Argument | Optional, Default: 10 |
| **9** | `soa_record.refresh_time` | Argument | Optional, Default: 3600 |
| **10** | `soa_record.retry_time` | Argument | Optional, Default: 300 |
| **11** | `soa_record.ttl` | Argument | Optional, Default: 3600 (property-level) |
| **12** | `soa_record.tags` | Argument | Optional (maps to metadata) |

All tasks #6-#12 can proceed in parallel as they are independent field implementations within the skeleton.

## Edge Case Analysis

### Null Semantics
- **`var.soa_record == null`**: No SOA record customization, `post_creation0` is `null`, Azure uses default SOA record
- **`var.soa_record != null`**: Full post-creation structure is created, SOA record is customized

### Boundary Conditions
- **Empty soa_record**: Not possible due to Terraform type system - if set, must be object with at least `email` (Required)
- **All optional fields null**: Valid - defaults will be applied by child tasks
- **MaxItems: 1**: Enforced by Terraform schema, guaranteed single object or null

### Idempotency
- Block presence tracked via boolean conversion (`true`/`null`) for stable ForceNew trigger
- Individual field changes handled by child tasks (Tasks #6-#12)
- Post-creation operation conditional prevents unnecessary API calls when block is null

### Safe References
- âœ… All references to `var.soa_record` are null-checked before access
- âœ… Nested conditional in `body.properties.merge()` prevents accessing fields when block is null
- âœ… `post_creation0` and `post_creation0_sensitive_body` both null when block is null

## Critical Review

### Exact Provider Behavior Replication
âœ… **Post-creation pattern**: Matches provider's two-phase create (zone first, then SOA record)
âœ… **ForceNew tracking**: Block-level ForceNew correctly tracked in `replace_triggers_external_values`
âœ… **API resource type**: Correct type `Microsoft.Network/privateDnsZones/SOA@2024-06-01`
âœ… **Conditional structure**: Null safety matches provider's `if v, ok := d.GetOk("soa_record")` check

### No Simplified/Conservative Approaches
- âŒ Did NOT simplify to put SOA in main body (would be incorrect - separate API call required)
- âŒ Did NOT skip ForceNew tracking (block is explicitly ForceNew in schema)
- âŒ Did NOT flatten structure (maintains correct nesting for post-creation pattern)

### Completeness
- âœ… Created skeleton with all 7 field placeholders
- âœ… Added both `post_creation0` and `post_creation0_sensitive_body`
- âœ… Added outputs for both post-creation locals
- âœ… Integrated with `local.locks` (will be populated by Task #4 if needed)

## Checklist

- âœ… Block skeleton created in correct local (`post_creation0`, not `body`)
- âœ… ForceNew wrapped: `{ value = var.soa_record != null ? true : null }`
- âœ… All logic exactly replicated from provider (two-phase pattern, conditional creation)
- âœ… Validations delegated to child tasks (Task #6 will handle cross-field email validation)
- âœ… No TODO comments needed (this is skeleton creation, not field migration)
- âœ… Hidden fields checked - none found
- âœ… No deferred work from following.md (file doesn't exist yet)
- âœ… Critical review completed - null safety, idempotency, safe references verified
- âœ… Edge Case Analysis included
- âœ… Proof document created
- âœ… Ready to update track.md to "Pending for check"
- âœ… Self-Review: Only skeleton structure added, no individual field implementations, no content from other tasks

## Deferred Work

### Cross-Field Validation
The email length validation that combines `name` and `email` is deferred to **Task #6** (owner of the `email` field):
```go
val := fmt.Sprintf("%s%s", id.PrivateDnsZoneName, strings.TrimSuffix(*soaRecord.Email, "."))
if len(val) > 253 {
    return fmt.Errorf("...")
}
```

This validation will be implemented in `variables.tf` within the `soa_record` variable's validation block, referencing `var.name`.

---

## âš ï¸ CHECKER VALIDATION - ISSUES FOUND AND CORRECTED

**Checked by:** Checker Agent
**Date:** 2025-12-23
**Task:** #5 - soa_record

### Issues Identified

#### Issue 1: Unstable Keys with Nested Merge and Conditional

**Problem:**
The executor used a `merge()` pattern with nested conditional that could create unstable keys in the `post_creation0.body.properties` structure:

**Executor's Implementation:**
```hcl
body = {
  properties = merge(
    {
      # ttl = ... # Task #11
    },
    var.soa_record != null ? {
      soaRecord = {
        # fields...
      }
      # metadata = ... # Task #12
    } : {}
  )
}
```

**Why This Violates executor.md:**
From executor.md lines 207-211:
> **MANDATORY: Stable Keys** - Keys MUST NOT appear/disappear across applies
> âŒ `merge({ a = {...} }, cond ? { b = {...} } : {})`
> âœ… `{ a = {...}, b = { value = cond ? val : "" } }`

And from checker.md lines 249-290:
> **ðŸš¨ CRITICAL: Shared Path Merge Check**
> Check for **duplicate parent keys** in merge statements that would cause overwrites
> Keys MUST NOT appear/disappear based on condition

**Root Cause:**
1. The `merge()` pattern creates two objects at the same level
2. While they don't have overlapping keys currently, the structure allows `soaRecord` and `metadata` keys to appear/disappear based on the outer condition
3. This violates the stable keys requirement - keys should always be present in the structure
4. The nested conditional `var.soa_record != null ? { soaRecord = {...} } : {}` is redundant since the entire `post_creation0` is already conditional on `var.soa_record != null`

### Corrections Made

#### Fix 1: Stable Key Structure

**Changed Files:**
- `migrate_main.tf`: Removed `merge()` and nested conditional, using stable structure

**New Implementation:**
```hcl
post_creation0 = var.soa_record != null ? {
  azapi_header = {
    type = "Microsoft.Network/privateDnsZones/SOA@2024-06-01"
  }
  body = {
    properties = {
      # ttl = ... # Task #11
      soaRecord = {
        # email = ... # Task #6
        # expireTime = ... # Task #7
        # minimumTtl = ... # Task #8
        # refreshTime = ... # Task #9
        # retryTime = ... # Task #10
      }
      # metadata = ... # Task #12
    }
  }
  locks = local.locks
} : null
```

**Why This is EXACT:**
1. âœ… **Stable keys**: All keys (`ttl`, `soaRecord`, `metadata`) are always present when `post_creation0` is not null
2. âœ… **No redundant conditionals**: The outer `var.soa_record != null` check is sufficient - no need for nested conditionals inside
3. âœ… **No merge() issues**: Direct object structure eliminates shallow merge problems
4. âœ… **Matches provider behavior**: Provider checks `if v, ok := d.GetOk("soa_record")` once, then processes all fields unconditionally inside that block
5. âœ… **Proper skeleton**: Child tasks (#6-#12) will fill in the placeholder comments with actual field assignments

**Verification:**
- Scenario 1: `var.soa_record = null` â†’ `post_creation0 = null` âœ…
- Scenario 2: `var.soa_record = { email = "admin@example.com" }` â†’ Full structure created with all keys present âœ…
- Edge Case: All keys remain stable across applies, no keys appear/disappear âœ…

### Compliance Statement

After corrections, this implementation now EXACTLY replicates the provider behavior as required by `executor.md`. The stable key structure ensures:
- No keys appear/disappear across applies
- Proper post-creation pattern with correct resource type
- Block-level ForceNew tracking
- Clean skeleton ready for child tasks

**Status:** CORRECTED AND APPROVED âœ…
